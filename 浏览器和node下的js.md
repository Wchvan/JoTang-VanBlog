# 浏览器与node.js的区别


## 表面的区别

1. 浏览器和node.js都可以看作是JS的运行平台，浏览器是JS在客户端的运行时环境，而node.js是JS在服务端的运行环境。
2. JS运行在浏览器端，用于用户的交互效果。JS运行在node.js，用于服务器的操作。
3. JS需要浏览器的JS引擎进行解析执行，但是不同浏览器的JS引擎不同，存在兼容性问题。而node.js是基于 chrome v8引擎的运行时环境，无兼容性问题。
4. 对于ECMAScript语法来说，在node.js和浏览器中都能运行。node.js无法使用DOM和BOM的操作，浏览器无法执行node.js中的文件操作等功能。
5. 浏览器下this指向window,nodejs中this指向global
6. 使用的模块标准不同，nodejs使用的是CommonJs的模块标准，而浏览器使用的是ES的模块标准。所以nodejs中使用的是require()导入模块；浏览器中js使用的是import的方式导入。

补充 -- CommonJs 和 ES6 特点和区别（有些地方不懂后面回头看）：

CommonJs：

1. 对于基本数据类型，属于复制。即会被模块缓存，如果在另外一个模块导入相同的变量也可以对该变量进行赋值
2. 对于复杂数据类型，是浅拷贝。由于两个模块引用对象指向同一内存空间，因此对该模块的值作出修改时会影响到另一个模块
3. 当使用require命令加载某一个模块时，就会运行整个模块的代码
4. 当使用require命令加载同一个模块的时候，不会再执行该模块，而是取到缓存之中的值，CommonJS模块无论加载多少次，都只会在第一次加载的时候运行一次，以后在加载都是在缓存中取值返回第一次运行的结果，除非手动清除系统缓存
5. 循环加载时，属于加载时执行。即脚本代码在require的时候就会全部执行，一旦出现某个模块被“循环加载”，就只输出已经执行的部分，还未执行的部分不会输出

ES6：

1. 静态化，必须定义在顶部，不能使用条件语句，自动采用严格模式
2. treeshaking(webpack会在打包的时候忽略掉没有用的代码)和编译优化，以及在webpack3中作用域的提升
3. 外部可以拿到实时的值而不是缓存中的值，是引用而不是拷贝
4. es6模块中的值是属于动态只读引用
5. 对于只读来说，就是不能修改引入变量的值，import变量是只读的，无论是基本数据类型还是复杂数据类型，当模块遇到import命令的时候。就会生成一个只读引用。等到脚本真正执行的时候，再根据这个只读引用到被加载的那个模块里面去取值
6. 对于动态来说，原始值发生变化，import加载的值也发生变化，无论是基本数据类型还是复杂数据类型
7. 循环加载时，es6模块时动态引用的，只要两个模块之间存在某个引用，代码就能构执行

区别：

1. CommonJS 模块输出的是一个值的拷贝（也就是说，一旦输出一个值，模块内部的变变化影响不到这个值），ES6 模块输出的是值的引用。
2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

## 底层核心

浏览器和Node 环境下，microtask 任务队列的执行时机不同

Node端，microtask 在事件循环的各个阶段之间执行
浏览器端，microtask 在事件循环的 macrotask 执行完之后执行

## 参考链接
[浏览器与node.js的区别](https://blog.csdn.net/u012174809/article/details/124359642)
[浏览器与Node的事件循环(Event Loop)有何区别?](https://blog.csdn.net/z591102/article/details/111588572)
[详解CommonJS模块与ES6模块](https://blog.csdn.net/weixin_43514149/article/details/107425932)